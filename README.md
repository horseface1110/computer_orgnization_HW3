# computer_orgnization_HW3

### 基本參數
  * 2 1 32 ，這個填進去之後orgin就不用改了
### 思考邏輯
  * 他要看的是如何處理新資料進cache時的擺放位置，所以可以專注在函式victimes上就好
    * FIFO：本來想用queue處理，但發現批量創queue蠻麻煩的，所以用第一個進來放way 1，第二個放way 2....，滿了回頭
      * 實作方式：用一維陣列紀錄目前在這個set中，資料已經放到哪個way了
      * 需要改的：原本給的idx計算方式很好用，不用改，只需要動way 這個變數的賦值方式就好
    * LRU：最久沒用到的。因為個會需要考慮到有成功hit的狀況，所以除了victimes還需要注意check_tag成功時的狀況
      * 助教在check_tag成功時的地方的code沒有用大括號，很bad，要注意
      * 實作方式：用一個二維陣列紀錄每個set中每個way距離上次被hit的時間，須注意：replace後跟成功hit的狀況都會更新最近的使用時間
      * 需要改的：check_tag跟victimes都需要改，
        *  check_tag：成功後要先把每個way的使用時間都+1,再把hit到的那個的使用時間歸零
        *  victimize：先把這個set裡的way使用時間都+1，這樣不會影響順序，反正之後也要加一可以省迴圈數。再遍歷這個set裡所有的way，看哪個值現在最大，就replace他       
   * LFU：使用頻率最低的。因為個會需要考慮到有成功hit的狀況，所以除了victimes還需要注意check_tag成功時的狀況
      * 教學說本來就會造成最晚進來的那個幾乎會一直被replace，所以是正常的
      * 實作方式：用一個二維陣列紀錄每個set中每個way目前被使用幾次了，須注意：replace後跟成功hit的狀況都會改變目前使用次數。replace會歸零，hit會加1
      * 需要改的：check_tag跟victimes都需要改，
        * check_tag：成功後要把這個way的使用次數值+1
        * victimize：先遍歷整個set看哪個Way的使用次數最少，就把他replace掉，然後把它的使用次數歸零
      * SELF：我這邊是使用MRU策略，因為看起來最簡都最好做。解釋說他是FILO的策略，意思是第一個進來的永遠不會被丟掉，因為需要pop的時候都是有東西要進來的時候，所以不像一般的堆疊那麼單純，這個策略會讓最後一個way的值一直被replace
        * 實作方式：做一個一維陣列，儲存目前每個set資料儲存到哪個way了
        * 需要改的：原本給的idx計算方式很好用，不用改。讓way這個變數的值 = 目前儲存到的way的下一個，但如果已經達到最大way數了，就讓它減一。意思是他會一直只在最後一個way做replace
